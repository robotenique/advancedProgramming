Aluno:  Juliano Garcia de Oliveira NºUSP: 9277086

O programa mostra a diferença (e comprova que há branch prediction) de tempo
de acordo com um código feito propositalmente para ser ineficiente para o branch
predictor (isto é, o branch predictor não vai conseguir otimizar).

O programa é muito simples:

Tenho um vetor de tamanho N, com números inteiros distintos de 1 a N.
O programa percore o vetor, e verifica para cada elemento se ele é maior que
chão de N/2. Se sim, soma na variável 'a', senão na variável 'b'. Ou seja, como
metade dos elementos são maiores que N/2, e metade menores ou iguais (considerando
um N par), o programa entra N/2 vezes no if, e N/2 vezes no else.

Versão Otimizada:
    A versão otimizada é apenas o vetor com os objetos ordenados. Assim, nas N/2
    primeiras iterações do while, nunca entrará no loop, para em seguida, nos últimos
    N/2 elementos do vetor, sempre entrará. Assim, o branch predictor percebe que
    não entrar no if é o que está acontecendo e vai começar a continuar na branch
    do else. Quando há a troca ele pode errar, mas a partir daí ele sempre vai
    entrar no if, e a branch vai ser ajustada.

Versão não Otimizada:
    Antes de medir o tempo, aplico o algoritmo de Fisher-Yates para embaralhar os
    elementos do vetor. E então, faz o mesmo processo de antes, percorre toda a lista
    e vai verificando se o número em questão é maior que N/2. Assim como no caso
    anterior, no total, entrará no if N/2 vezes, e no else N/2 vezes, porque os
    números do vetor não foram alterados (apenas a ordem). Porém, como não irá
    ter um padrão bem definido, o branch predictor irá errar 50% das vezes, tornando
    essa execução bem mais lenta, embora os dois programas façam exatamente a mesma
    coisa no final das contas, com os mesmos números.
